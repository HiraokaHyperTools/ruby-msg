<!DOCTYPE html PUBLIC "-//W3C//DTD HTML 4.01//EN" "http://www.w3.org/TR/html4/strict.dtd">
<html lang='en'>
<head>
<title>Mapi::RTF</title>
<meta content='text/html; charset=UTF-8' http-equiv='Content-Type'>
<link href='../../css/style.css' media='screen' rel='stylesheet' type='text/css'>
<script type='text/javascript'>
  function popupCode(url) {
    window.open(url, "Code", "resizable=yes,scrollbars=yes,toolbar=no,status=no,height=150,width=400")
  }
  
  function toggleCode(id) {
    var code = document.getElementById(id)
  
    code.style.display = code.style.display != 'block' ? 'block' : 'none'
    return true
  }
  
  // Make codeblocks hidden by default
  document.writeln('<' + 'style type="text/css">.method .source pre { display: none }<\/style>')
</script>
</head>
<body class='page'>
<div class='class' id='wrapper'>
<div class='header'>
<h1 class='name'><span class='type'>module</span>
Mapi::RTF
</h1>
<ol class='paths'>
<li>
<a href="../../files/lib/mapi/rtf_rb.html">lib/mapi/rtf.rb</a>
</li>
</ol>
</div>
<div id='content'>
<div id='text'>
<div id='description'>
<h1 id="module-Mapi::RTF-label-Introduction">Introduction<span><a href="#module-Mapi::RTF-label-Introduction">&para;</a> <a href="#top">&uarr;</a></span></h1>

<p>The <code>RTF</code> module contains a few helper functions for dealing with rtf in mapi messages: <code>rtfdecompr</code>, and <code>rtf2html</code>.</p>

<p>Both were ported from their original C versions for simplicity&#39;s sake.</p>
</div>
<div id='method-list'>
<h2>Methods</h2>
<h3>Public Class</h3>
<ol>
<li><a href="#method-c-rtf2html">rtf2html</a></li>
<li><a href="#method-c-rtfdecompr">rtfdecompr</a></li>
</ol>
</div>
<div id='context'>
</div>
<div id='class-list'>
<h2>Classes and Modules</h2>
<ol>
<li><a href="RTF/Converter.html">Mapi::RTF::Converter</a></li>
<li><a href="RTF/Tokenizer.html">Mapi::RTF::Tokenizer</a></li>
</ol>
</div>
<div id='section'>
<div id='constants-list'>
<h2>Constants</h2>
<div class='name-list'>
<table summary='Constants'>
<tr class='top-aligned-row context-row'>
<td class='context-item-name'>RTF_PREBUF</td>
<td>=</td>
<td class='context-item-value'>"{\\rtf1\\ansi\\mac\\deff0\\deftab720{\\fonttbl;}" \
"{\\f0\\fnil \\froman \\fswiss \\fmodern \\fscript " \
"\\fdecor MS Sans SerifSymbolArialTimes New RomanCourier" \
"{\\colortbl\\red0\\green0\\blue0\n\r\\par " \
"\\pard\\plain\\f0\\fs20\\b\\i\\u\\tab\\tx"</td>
<td>&nbsp;</td>
<td class='context-item-desc'></td>
</tr>
</table>
</div>
</div>
<div id='methods'>
<h2>Public Class methods</h2>
<div class='public-class method' id='method-method-c-rtf2html'>
<a name='method-c-rtf2html'></a>
<div class='synopsis'>
<span class='name'>rtf2html</span><span class='arguments'>(rtf)</span>

</div>
<div class='description'>

<p>Note, this is a conversion of the original C code. Not great - needs tests and some refactoring, and an attempt to correct some inaccuracies. Hacky but works.</p>

<p>Returns <code>nil</code> if it doesn&#39;t look like an rtf encapsulated rtf.</p>

<p>Some cases that the original didn&#39;t deal with have been patched up, eg from  this chunk, where there are tags outside of the htmlrtf ignore block.</p>

<p>“{*\htmltag116 &lt;br /&gt;}\htmlrtf \line \htmlrtf0 \line {*\htmltag84 &lt;a href…”</p>

<p>We take the approach of ignoring all rtf tags not explicitly handled. A proper parse tree would be nicer to work with. will need to look for ruby rtf library</p>

<p>Some of the original comment to the c code is excerpted here:</p>

<p>Sometimes in MAPI, the PR_BODY_HTML property contains the HTML of a message. But more usually, the HTML is encoded inside the <a href="RTF.html"><code>RTF</code></a> body (which you get in the PR_RTF_COMPRESSED property). These routines concern the decoding of the HTML from this <a href="RTF.html"><code>RTF</code></a> body.</p>

<p>An encoded htmlrtf file is a valid <a href="RTF.html"><code>RTF</code></a> document, but which contains additional html markup information in its comments, and sometimes contains the equivalent rtf markup outside the comments. Therefore, when it is displayed by a plain simple <a href="RTF.html"><code>RTF</code></a> reader, the html comments are ignored and only the rtf markup has effect. Typically, this rtf markup is not as rich as the html markup would have been. But for an html-aware reader (such as the code below), we can ignore all the rtf markup, and extract the html markup out of the comments, and get a valid html document.</p>

<p>There are actually two kinds of html markup in comments. Most of them are prefixed by “*htmltagNNN”, for some number NNN. But sometimes there&#39;s one prefixed by “*mhtmltagNNN” followed by “*htmltagNNN”. In this case, the two are equivalent, but the m-tag is for a MIME Multipart/Mixed <a href="Message.html"><code>Message</code></a> and contains tags that refer to content-ids (e.g. img src=“cid:072344a7”) while the normal tag just refers to a name (e.g. img src=“fred.jpg”) The code below keeps the m-tag and discards the normal tag. If there are any m-tags like this, then the message also contains an attachment with a PR_CONTENT_ID property e.g. “072344a7”. Actually, sometimes the m-tag is e.g. img src=“<a target="_top" href="http://outlook/welcome.html">outlook/welcome.html</a>” and the attachment has a PR_CONTENT_LOCATION “<a target="_top" href="http://outlook/welcome.html">outlook/welcome.html</a>” instead of a PR_CONTENT_ID.</p>

</div>
<div class='source'>
<a class='source-toggle' href='#' onclick='toggleCode(&#39;method-c-rtf2html-source&#39;); return false'>
[show source]
</a>
<pre id='method-c-rtf2html-source'><span class="ruby-comment"># File lib/mapi/rtf.rb, line 229</span>&#x000A;<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">rtf2html</span> <span class="ruby-identifier">rtf</span>&#x000A;        <span class="ruby-identifier">scan</span> = <span class="ruby-constant">StringScanner</span>.<span class="ruby-identifier">new</span> <span class="ruby-identifier">rtf</span>&#x000A;        <span class="ruby-comment"># require \fromhtml. is this worth keeping? apparently you see \\fromtext if it</span>&#x000A;        <span class="ruby-comment"># was converted from plain text.</span>&#x000A;        <span class="ruby-keyword">return</span> <span class="ruby-keyword">nil</span> <span class="ruby-keyword">unless</span> <span class="ruby-identifier">rtf</span>[<span class="ruby-string">&quot;\\fromhtml&quot;</span>]&#x000A;        <span class="ruby-identifier">html</span> = <span class="ruby-string">&#39;&#39;</span>&#x000A;        <span class="ruby-identifier">ignore_tag</span> = <span class="ruby-keyword">nil</span>&#x000A;        <span class="ruby-comment"># skip up to the first htmltag. return nil if we don&#39;t ever find one</span>&#x000A;        <span class="ruby-keyword">return</span> <span class="ruby-keyword">nil</span> <span class="ruby-keyword">unless</span> <span class="ruby-identifier">scan</span>.<span class="ruby-identifier">scan_until</span> <span class="ruby-regexp">/(?=\{\\\*\\htmltag)/</span>&#x000A;        <span class="ruby-keyword">until</span> <span class="ruby-identifier">scan</span>.<span class="ruby-identifier">empty?</span>&#x000A;                <span class="ruby-keyword">if</span> <span class="ruby-identifier">scan</span>.<span class="ruby-identifier">scan</span> <span class="ruby-regexp">/\{/</span>&#x000A;                <span class="ruby-keyword">elsif</span> <span class="ruby-identifier">scan</span>.<span class="ruby-identifier">scan</span> <span class="ruby-regexp">/\}/</span>&#x000A;                <span class="ruby-keyword">elsif</span> <span class="ruby-identifier">scan</span>.<span class="ruby-identifier">scan</span> <span class="ruby-regexp">/\\\*\\htmltag(\d+) ?/</span>&#x000A;                        <span class="ruby-comment">#p scan[1]</span>&#x000A;                        <span class="ruby-keyword">if</span> <span class="ruby-identifier">ignore_tag</span> <span class="ruby-operator">==</span> <span class="ruby-identifier">scan</span>[<span class="ruby-value">1</span>]&#x000A;                                <span class="ruby-identifier">scan</span>.<span class="ruby-identifier">scan_until</span> <span class="ruby-regexp">/\}/</span>&#x000A;                                <span class="ruby-identifier">ignore_tag</span> = <span class="ruby-keyword">nil</span>&#x000A;                        <span class="ruby-keyword">end</span>&#x000A;                <span class="ruby-keyword">elsif</span> <span class="ruby-identifier">scan</span>.<span class="ruby-identifier">scan</span> <span class="ruby-regexp">/\\\*\\mhtmltag(\d+) ?/</span>&#x000A;                                <span class="ruby-identifier">ignore_tag</span> = <span class="ruby-identifier">scan</span>[<span class="ruby-value">1</span>]&#x000A;                <span class="ruby-keyword">elsif</span> <span class="ruby-identifier">scan</span>.<span class="ruby-identifier">scan</span> <span class="ruby-regexp">/\\par ?/</span>&#x000A;                        <span class="ruby-identifier">html</span> <span class="ruby-operator">&lt;&lt;</span> <span class="ruby-string">&quot;\r\n&quot;</span>&#x000A;                <span class="ruby-keyword">elsif</span> <span class="ruby-identifier">scan</span>.<span class="ruby-identifier">scan</span> <span class="ruby-regexp">/\\tab ?/</span>&#x000A;                        <span class="ruby-identifier">html</span> <span class="ruby-operator">&lt;&lt;</span> <span class="ruby-string">&quot;\t&quot;</span>&#x000A;                <span class="ruby-keyword">elsif</span> <span class="ruby-identifier">scan</span>.<span class="ruby-identifier">scan</span> <span class="ruby-regexp">/\\&#39;([0-9A-Za-z]{2})/</span>&#x000A;                        <span class="ruby-identifier">html</span> <span class="ruby-operator">&lt;&lt;</span> <span class="ruby-identifier">scan</span>[<span class="ruby-value">1</span>].<span class="ruby-identifier">hex</span>.<span class="ruby-identifier">chr</span>&#x000A;                <span class="ruby-keyword">elsif</span> <span class="ruby-identifier">scan</span>.<span class="ruby-identifier">scan</span> <span class="ruby-regexp">/\\pntext/</span>&#x000A;                        <span class="ruby-identifier">scan</span>.<span class="ruby-identifier">scan_until</span> <span class="ruby-regexp">/\}/</span>&#x000A;                <span class="ruby-keyword">elsif</span> <span class="ruby-identifier">scan</span>.<span class="ruby-identifier">scan</span> <span class="ruby-regexp">/\\htmlrtf/</span>&#x000A;                        <span class="ruby-identifier">scan</span>.<span class="ruby-identifier">scan_until</span> <span class="ruby-regexp">/\\htmlrtf0 ?/</span>&#x000A;                <span class="ruby-comment"># a generic throw away unknown tags thing.</span>&#x000A;                <span class="ruby-comment"># the above 2 however, are handled specially</span>&#x000A;                <span class="ruby-keyword">elsif</span> <span class="ruby-identifier">scan</span>.<span class="ruby-identifier">scan</span> <span class="ruby-regexp">/\\[a-z-]+(\d+)? ?/</span>&#x000A;                <span class="ruby-comment">#elsif scan.scan /\\li(\d+) ?/</span>&#x000A;                <span class="ruby-comment">#elsif scan.scan /\\fi-(\d+) ?/</span>&#x000A;                <span class="ruby-keyword">elsif</span> <span class="ruby-identifier">scan</span>.<span class="ruby-identifier">scan</span> <span class="ruby-regexp">/[\r\n]/</span>&#x000A;                <span class="ruby-keyword">elsif</span> <span class="ruby-identifier">scan</span>.<span class="ruby-identifier">scan</span> <span class="ruby-regexp">/\\([{}\\])/</span>&#x000A;                        <span class="ruby-identifier">html</span> <span class="ruby-operator">&lt;&lt;</span> <span class="ruby-identifier">scan</span>[<span class="ruby-value">1</span>]&#x000A;                <span class="ruby-keyword">elsif</span> <span class="ruby-identifier">scan</span>.<span class="ruby-identifier">scan</span> <span class="ruby-regexp">/(.)/</span>&#x000A;                        <span class="ruby-identifier">html</span> <span class="ruby-operator">&lt;&lt;</span> <span class="ruby-identifier">scan</span>[<span class="ruby-value">1</span>]&#x000A;                <span class="ruby-keyword">else</span>&#x000A;                        <span class="ruby-identifier">p</span> <span class="ruby-value">:wtf</span>&#x000A;                <span class="ruby-keyword">end</span>&#x000A;        <span class="ruby-keyword">end</span>&#x000A;        <span class="ruby-identifier">html</span>.<span class="ruby-identifier">strip</span>.<span class="ruby-identifier">empty?</span> <span class="ruby-operator">?</span> <span class="ruby-keyword">nil</span> <span class="ruby-operator">:</span> <span class="ruby-identifier">html</span>&#x000A;<span class="ruby-keyword">end</span></pre>
</div>
</div>
<div class='public-class method' id='method-method-c-rtfdecompr'>
<a name='method-c-rtfdecompr'></a>
<div class='synopsis'>
<span class='name'>rtfdecompr</span><span class='arguments'>(data)</span>

</div>
<div class='description'>

<p>Decompresses compressed rtf <code>data</code>, as found in the mapi property <code>PR_RTF_COMPRESSED</code>. Code converted from my C version, which in turn I wrote from a Java source, in JTNEF I believe.</p>

<p>C version was modified to use circular buffer for back references, instead of the optimization of the Java version to index directly into output buffer. This was in preparation to support streaming in a read/write neutral fashion.</p>

</div>
<div class='source'>
<a class='source-toggle' href='#' onclick='toggleCode(&#39;method-c-rtfdecompr-source&#39;); return false'>
[show source]
</a>
<pre id='method-c-rtfdecompr-source'><span class="ruby-comment"># File lib/mapi/rtf.rb, line 140</span>&#x000A;<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">rtfdecompr</span> <span class="ruby-identifier">data</span>&#x000A;        <span class="ruby-identifier">io</span>  = <span class="ruby-constant">StringIO</span>.<span class="ruby-identifier">new</span> <span class="ruby-identifier">data</span>&#x000A;        <span class="ruby-identifier">buf</span> = <span class="ruby-constant">RTF_PREBUF</span> <span class="ruby-operator">+</span> <span class="ruby-string">&quot;\x00&quot;</span> <span class="ruby-operator">*</span> (<span class="ruby-value">4096</span> <span class="ruby-operator">-</span> <span class="ruby-constant">RTF_PREBUF</span>.<span class="ruby-identifier">length</span>)&#x000A;        <span class="ruby-identifier">wp</span>  = <span class="ruby-constant">RTF_PREBUF</span>.<span class="ruby-identifier">length</span>&#x000A;        <span class="ruby-identifier">rtf</span> = <span class="ruby-string">&#39;&#39;</span>&#x000A;&#x000A;        <span class="ruby-comment"># get header fields (as defined in RTFLIB.H)</span>&#x000A;        <span class="ruby-identifier">compr_size</span>, <span class="ruby-identifier">uncompr_size</span>, <span class="ruby-identifier">magic</span>, <span class="ruby-identifier">crc32</span> = <span class="ruby-identifier">io</span>.<span class="ruby-identifier">read</span>(<span class="ruby-value">16</span>).<span class="ruby-identifier">unpack</span> <span class="ruby-string">&#39;V*&#39;</span>&#x000A;        <span class="ruby-comment">#warn &quot;compressed-RTF data size mismatch&quot; unless io.size == data.compr_size + 4</span>&#x000A;&#x000A;        <span class="ruby-comment"># process the data</span>&#x000A;        <span class="ruby-keyword">case</span> <span class="ruby-identifier">magic</span>&#x000A;        <span class="ruby-keyword">when</span> <span class="ruby-value">0x414c454d</span> <span class="ruby-comment"># &quot;MELA&quot; magic number that identifies the stream as a uncompressed stream</span>&#x000A;                <span class="ruby-identifier">rtf</span> = <span class="ruby-identifier">io</span>.<span class="ruby-identifier">read</span> <span class="ruby-identifier">uncompr_size</span>&#x000A;        <span class="ruby-keyword">when</span> <span class="ruby-value">0x75465a4c</span> <span class="ruby-comment"># &quot;LZFu&quot; magic number that identifies the stream as a compressed stream</span>&#x000A;                <span class="ruby-identifier">flag_count</span> = <span class="ruby-value">-1</span>&#x000A;                <span class="ruby-identifier">flags</span> = <span class="ruby-keyword">nil</span>&#x000A;                <span class="ruby-keyword">while</span> <span class="ruby-identifier">rtf</span>.<span class="ruby-identifier">length</span> <span class="ruby-operator">&lt;</span> <span class="ruby-identifier">uncompr_size</span> <span class="ruby-keyword">and</span> <span class="ruby-operator">!</span><span class="ruby-identifier">io</span>.<span class="ruby-identifier">eof?</span>&#x000A;                        <span class="ruby-comment"># each flag byte flags 8 literals/references, 1 per bit</span>&#x000A;                        <span class="ruby-identifier">flags</span> = ((<span class="ruby-identifier">flag_count</span> <span class="ruby-operator">+=</span> <span class="ruby-value">1</span>) <span class="ruby-operator">%</span> <span class="ruby-value">8</span> <span class="ruby-operator">==</span> <span class="ruby-value">0</span>) <span class="ruby-operator">?</span> <span class="ruby-identifier">io</span>.<span class="ruby-identifier">getbyte</span> <span class="ruby-operator">:</span> <span class="ruby-identifier">flags</span> <span class="ruby-operator">&gt;&gt;</span> <span class="ruby-value">1</span>&#x000A;                        <span class="ruby-keyword">if</span> <span class="ruby-value">1</span> <span class="ruby-operator">==</span> (<span class="ruby-identifier">flags</span> <span class="ruby-operator">&amp;</span> <span class="ruby-value">1</span>) <span class="ruby-comment"># each flag bit is 1 for reference, 0 for literal</span>&#x000A;                                <span class="ruby-identifier">rp</span>, <span class="ruby-identifier">l</span> = <span class="ruby-identifier">io</span>.<span class="ruby-identifier">getbyte</span>, <span class="ruby-identifier">io</span>.<span class="ruby-identifier">getbyte</span>&#x000A;                                <span class="ruby-comment"># offset is a 12 byte number. 2^12 is 4096, so thats fine</span>&#x000A;                                <span class="ruby-identifier">rp</span> = (<span class="ruby-identifier">rp</span> <span class="ruby-operator">&lt;&lt;</span> <span class="ruby-value">4</span>) <span class="ruby-operator">|</span> (<span class="ruby-identifier">l</span> <span class="ruby-operator">&gt;&gt;</span> <span class="ruby-value">4</span>) <span class="ruby-comment"># the offset relative to block start</span>&#x000A;                                <span class="ruby-identifier">l</span> = (<span class="ruby-identifier">l</span> <span class="ruby-operator">&amp;</span> <span class="ruby-value">0xf</span>) <span class="ruby-operator">+</span> <span class="ruby-value">2</span> <span class="ruby-comment"># the number of bytes to copy</span>&#x000A;                                <span class="ruby-identifier">l</span>.<span class="ruby-identifier">times</span> <span class="ruby-keyword">do</span>&#x000A;                                        <span class="ruby-identifier">rtf</span> <span class="ruby-operator">&lt;&lt;</span> <span class="ruby-identifier">buf</span>[<span class="ruby-identifier">wp</span>] = <span class="ruby-identifier">buf</span>[<span class="ruby-identifier">rp</span>]&#x000A;                                        <span class="ruby-identifier">wp</span> = (<span class="ruby-identifier">wp</span> <span class="ruby-operator">+</span> <span class="ruby-value">1</span>) <span class="ruby-operator">%</span> <span class="ruby-value">4096</span>&#x000A;                                        <span class="ruby-identifier">rp</span> = (<span class="ruby-identifier">rp</span> <span class="ruby-operator">+</span> <span class="ruby-value">1</span>) <span class="ruby-operator">%</span> <span class="ruby-value">4096</span>&#x000A;                                <span class="ruby-keyword">end</span>&#x000A;                        <span class="ruby-keyword">else</span>&#x000A;                                <span class="ruby-identifier">rtf</span> <span class="ruby-operator">&lt;&lt;</span> <span class="ruby-identifier">buf</span>[<span class="ruby-identifier">wp</span>] = <span class="ruby-identifier">io</span>.<span class="ruby-identifier">getbyte</span>.<span class="ruby-identifier">chr</span>&#x000A;                                <span class="ruby-identifier">wp</span> = (<span class="ruby-identifier">wp</span> <span class="ruby-operator">+</span> <span class="ruby-value">1</span>) <span class="ruby-operator">%</span> <span class="ruby-value">4096</span>&#x000A;                        <span class="ruby-keyword">end</span>&#x000A;                <span class="ruby-keyword">end</span>&#x000A;        <span class="ruby-keyword">else</span> <span class="ruby-comment"># unknown magic number</span>&#x000A;                <span class="ruby-identifier">raise</span> <span class="ruby-string">&quot;Unknown compression type (magic number 0x%08x)&quot;</span> <span class="ruby-operator">%</span> <span class="ruby-identifier">magic</span>&#x000A;        <span class="ruby-keyword">end</span>&#x000A;        &#x000A;        <span class="ruby-comment"># not sure if its due to a bug in the above code. doesn&#39;t seem to be</span>&#x000A;        <span class="ruby-comment"># in my tests, but sometimes there&#39;s a trailing null. we chomp it here,</span>&#x000A;        <span class="ruby-comment"># which actually makes the resultant rtf smaller than its advertised</span>&#x000A;        <span class="ruby-comment"># size (+uncompr_size+).</span>&#x000A;        <span class="ruby-identifier">rtf</span>.<span class="ruby-identifier">chomp!</span> <span class="ruby-value">0</span>.<span class="ruby-identifier">chr</span>&#x000A;        <span class="ruby-identifier">rtf</span>&#x000A;<span class="ruby-keyword">end</span></pre>
</div>
</div>
</div>
</div>

</div>
</div>

<div id='footer-push'></div>
</div>
<div id='footer'>
<a href="https://github.com/rdoc/hanna-nouveau"><strong>Hanna Nouveau</strong> RDoc template</a>
</div>
</body>
</html>
