<!DOCTYPE html PUBLIC "-//W3C//DTD HTML 4.01//EN" "http://www.w3.org/TR/html4/strict.dtd">
<html lang='en'>
<head>
<title>Mapi::Message</title>
<meta content='text/html; charset=UTF-8' http-equiv='Content-Type'>
<link href='../../css/style.css' media='screen' rel='stylesheet' type='text/css'>
<script type='text/javascript'>
  function popupCode(url) {
    window.open(url, "Code", "resizable=yes,scrollbars=yes,toolbar=no,status=no,height=150,width=400")
  }
  
  function toggleCode(id) {
    var code = document.getElementById(id)
  
    code.style.display = code.style.display != 'block' ? 'block' : 'none'
    return true
  }
  
  // Make codeblocks hidden by default
  document.writeln('<' + 'style type="text/css">.method .source pre { display: none }<\/style>')
</script>
</head>
<body class='page'>
<div class='class' id='wrapper'>
<div class='header'>
<h1 class='name'><span class='type'>class</span>
Mapi::Message
</h1>
<ol class='paths'>
<li>
<a href="../../files/lib/mapi/base_rb.html">lib/mapi/base.rb</a>
</li>
<li class='other'>
<a href="../../files/lib/mapi/convert_rb.html">lib/mapi/convert.rb</a>
</li>
<li class='other'>
<a href="../../files/lib/mapi/convert/contact_rb.html">lib/mapi/convert/contact.rb</a>
</li>
<li class='other'>
<a href="../../files/lib/mapi/convert/note-mime_rb.html">lib/mapi/convert/note-mime.rb</a>
</li>
<li class='other'>
<a href="../../files/lib/mapi/convert/note-tmail_rb.html">lib/mapi/convert/note-tmail.rb</a>
</li>
<li>
<a class='show' href='#' onclick='this.parentNode.parentNode.className += &quot; expanded&quot;; this.parentNode.removeChild(this); return false'>show all</a>
</li>
</ol>
<div class='parent'>
Superclass:
<strong><a href="Item.html">Item</a></strong>
</div>
</div>
<div id='content'>
<div id='text'>
<div id='description'>
<p>i refer to it as a message (as does mapi), although perhaps <a href="Item.html"><code>Item</code></a> is better, as its a more general concept than a message, as used in <a href="Pst.html"><code>Pst</code></a> files. though maybe i&#39;ll switch to using Mapi::Object as the base class there.</p>

<p>IMessage essentially, but there&#39;s also stuff like IMAPIFolder etc. so, for this to form basis for PST <a href="Item.html"><code>Item</code></a>, it&#39;d need to be more general.</p>
</div>
<div id='method-list'>
<h2>Methods</h2>
<h3>Public Instance</h3>
<ol>
<li><a href="#method-i-attachments">attachments</a></li>
<li><a href="#method-i-body_to_mime">body_to_mime</a></li>
<li><a href="#method-i-body_to_tmail">body_to_tmail</a></li>
<li><a href="#method-i-convert">convert</a></li>
<li><a href="#method-i-headers">headers</a></li>
<li><a href="#method-i-inspect">inspect</a></li>
<li><a href="#method-i-mime">mime</a></li>
<li><a href="#method-i-mime_type">mime_type</a></li>
<li><a href="#method-i-populate_headers">populate_headers</a></li>
<li><a href="#method-i-recipients">recipients</a></li>
<li><a href="#method-i-to_mime">to_mime</a></li>
<li><a href="#method-i-to_post">to_post</a></li>
<li><a href="#method-i-to_tmail">to_tmail</a></li>
<li><a href="#method-i-to_vcard">to_vcard</a></li>
<li><a href="#method-i-type">type</a></li>
</ol>
</div>
<div id='context'>
</div>
<div id='class-list'>
<h2>Classes and Modules</h2>
<ol>
<li><a href="Message/Post.html">Mapi::Message::Post</a></li>
<li><a href="Message/VcardConverter.html">Mapi::Message::VcardConverter</a></li>
</ol>
</div>
<div id='section'>
<div id='constants-list'>
<h2>Constants</h2>
<div class='name-list'>
<table summary='Constants'>
<tr class='top-aligned-row context-row'>
<td class='context-item-name'>CONVERSION_MAP</td>
<td>=</td>
<td class='context-item-value'>{
'text/x-vcard'   => [:to_vcard, 'vcf'],
'message/rfc822' => [:to_mime, 'eml'],
'text/plain'     => [:to_post, 'txt']
# ...
}</td>
<td>&nbsp;</td>
<td class='context-item-desc'></td>
</tr>
</table>
</div>
</div>
<div id='methods'>
<h2>Public Instance methods</h2>
<div class='public-instance method' id='method-method-i-attachments'>
<a name='method-i-attachments'></a>
<div class='synopsis'>
<span class='name'>attachments</span><span class='arguments'>()</span>

</div>
<div class='description'>

<p>these 2 collections should be provided by our subclasses</p>

</div>
<div class='source'>
<a class='source-toggle' href='#' onclick='toggleCode(&#39;method-i-attachments-source&#39;); return false'>
[show source]
</a>
<pre id='method-i-attachments-source'><span class="ruby-comment"># File lib/mapi/base.rb, line 87</span>&#x000A;<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">attachments</span>&#x000A;        <span class="ruby-identifier">raise</span> <span class="ruby-constant">NotImplementedError</span>&#x000A;<span class="ruby-keyword">end</span></pre>
</div>
</div>
<div class='public-instance method' id='method-method-i-body_to_mime'>
<a name='method-i-body_to_mime'></a>
<div class='synopsis'>
<span class='name'>body_to_mime</span><span class='arguments'>()</span>

</div>
<div class='description'>

</div>
<div class='source'>
<a class='source-toggle' href='#' onclick='toggleCode(&#39;method-i-body_to_mime-source&#39;); return false'>
[show source]
</a>
<pre id='method-i-body_to_mime-source'><span class="ruby-comment"># File lib/mapi/convert/note-mime.rb, line 146</span>&#x000A;<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">body_to_mime</span>&#x000A;        <span class="ruby-comment"># to create the body</span>&#x000A;        <span class="ruby-comment"># should have some options about serializing rtf. and possibly options to check the rtf</span>&#x000A;        <span class="ruby-comment"># for rtf2html conversion, stripping those html tags or other similar stuff. maybe want to</span>&#x000A;        <span class="ruby-comment"># ignore it in the cases where it is generated from incoming html. but keep it if it was the</span>&#x000A;        <span class="ruby-comment"># source for html and plaintext.</span>&#x000A;        <span class="ruby-keyword">if</span> <span class="ruby-identifier">props</span>.<span class="ruby-identifier">body_rtf</span> <span class="ruby-keyword">or</span> <span class="ruby-identifier">props</span>.<span class="ruby-identifier">body_html</span>&#x000A;                <span class="ruby-comment"># should plain come first?</span>&#x000A;                <span class="ruby-identifier">mime</span> = <span class="ruby-constant">Mime</span>.<span class="ruby-identifier">new</span> <span class="ruby-string">&quot;Content-Type: multipart/alternative\r\n\r\n&quot;</span>&#x000A;                <span class="ruby-comment"># its actually possible for plain body to be empty, but the others not.</span>&#x000A;                <span class="ruby-comment"># if i can get an html version, then maybe a callout to lynx can be made...</span>&#x000A;                <span class="ruby-identifier">mime</span>.<span class="ruby-identifier">parts</span> <span class="ruby-operator">&lt;&lt;</span> <span class="ruby-constant">Mime</span>.<span class="ruby-identifier">new</span>(<span class="ruby-string">&quot;Content-Type: text/plain\r\n\r\n&quot;</span> <span class="ruby-operator">+</span> <span class="ruby-identifier">props</span>.<span class="ruby-identifier">body</span>) <span class="ruby-keyword">if</span> <span class="ruby-identifier">props</span>.<span class="ruby-identifier">body</span>&#x000A;                <span class="ruby-comment"># this may be automatically unwrapped from the rtf if the rtf includes the html</span>&#x000A;                <span class="ruby-identifier">mime</span>.<span class="ruby-identifier">parts</span> <span class="ruby-operator">&lt;&lt;</span> <span class="ruby-constant">Mime</span>.<span class="ruby-identifier">new</span>(<span class="ruby-string">&quot;Content-Type: text/html\r\n\r\n&quot;</span>  <span class="ruby-operator">+</span> <span class="ruby-identifier">props</span>.<span class="ruby-identifier">body_html</span>) <span class="ruby-keyword">if</span> <span class="ruby-identifier">props</span>.<span class="ruby-identifier">body_html</span>&#x000A;                <span class="ruby-comment"># temporarily disabled the rtf. its just showing up as an attachment anyway.</span>&#x000A;                <span class="ruby-comment">#mime.parts &lt;&lt; Mime.new(&quot;Content-Type: text/rtf\r\n\r\n&quot;   + props.body_rtf)  if props.body_rtf</span>&#x000A;                <span class="ruby-comment"># its thus currently possible to get no body at all if the only body is rtf. that is not</span>&#x000A;                <span class="ruby-comment"># really acceptable FIXME</span>&#x000A;                <span class="ruby-identifier">mime</span>&#x000A;        <span class="ruby-keyword">else</span>&#x000A;                <span class="ruby-comment"># check no header case. content type? etc?. not sure if my Mime class will accept</span>&#x000A;                <span class="ruby-constant">Log</span>.<span class="ruby-identifier">debug</span> <span class="ruby-string">&quot;taking that other path&quot;</span>&#x000A;                <span class="ruby-comment"># body can be nil, hence the to_s</span>&#x000A;                <span class="ruby-constant">Mime</span>.<span class="ruby-identifier">new</span> <span class="ruby-string">&quot;Content-Type: text/plain\r\n\r\n&quot;</span> <span class="ruby-operator">+</span> <span class="ruby-identifier">props</span>.<span class="ruby-identifier">body</span>.<span class="ruby-identifier">to_s</span>&#x000A;        <span class="ruby-keyword">end</span>&#x000A;<span class="ruby-keyword">end</span></pre>
</div>
</div>
<div class='public-instance method' id='method-method-i-body_to_tmail'>
<a name='method-i-body_to_tmail'></a>
<div class='synopsis'>
<span class='name'>body_to_tmail</span><span class='arguments'>()</span>

</div>
<div class='description'>

</div>
<div class='source'>
<a class='source-toggle' href='#' onclick='toggleCode(&#39;method-i-body_to_tmail-source&#39;); return false'>
[show source]
</a>
<pre id='method-i-body_to_tmail-source'><span class="ruby-comment"># File lib/mapi/convert/note-tmail.rb, line 156</span>&#x000A;<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">body_to_tmail</span>&#x000A;        <span class="ruby-comment"># to create the body</span>&#x000A;        <span class="ruby-comment"># should have some options about serializing rtf. and possibly options to check the rtf</span>&#x000A;        <span class="ruby-comment"># for rtf2html conversion, stripping those html tags or other similar stuff. maybe want to</span>&#x000A;        <span class="ruby-comment"># ignore it in the cases where it is generated from incoming html. but keep it if it was the</span>&#x000A;        <span class="ruby-comment"># source for html and plaintext.</span>&#x000A;        <span class="ruby-keyword">if</span> <span class="ruby-identifier">props</span>.<span class="ruby-identifier">body_rtf</span> <span class="ruby-keyword">or</span> <span class="ruby-identifier">props</span>.<span class="ruby-identifier">body_html</span>&#x000A;                <span class="ruby-comment"># should plain come first?</span>&#x000A;                <span class="ruby-identifier">part</span> = <span class="ruby-constant">TMail</span><span class="ruby-operator">::</span><span class="ruby-constant">Mail</span>.<span class="ruby-identifier">new</span>&#x000A;                <span class="ruby-comment"># its actually possible for plain body to be empty, but the others not.</span>&#x000A;                <span class="ruby-comment"># if i can get an html version, then maybe a callout to lynx can be made...</span>&#x000A;                <span class="ruby-identifier">part</span>.<span class="ruby-identifier">parts</span> <span class="ruby-operator">&lt;&lt;</span> <span class="ruby-constant">TMail</span><span class="ruby-operator">::</span><span class="ruby-constant">Mail</span>.<span class="ruby-identifier">parse</span>(<span class="ruby-string">&quot;Content-Type: text/plain\r\n\r\n&quot;</span> <span class="ruby-operator">+</span> <span class="ruby-identifier">props</span>.<span class="ruby-identifier">body</span>) <span class="ruby-keyword">if</span> <span class="ruby-identifier">props</span>.<span class="ruby-identifier">body</span>&#x000A;                <span class="ruby-comment"># this may be automatically unwrapped from the rtf if the rtf includes the html</span>&#x000A;                <span class="ruby-identifier">part</span>.<span class="ruby-identifier">parts</span> <span class="ruby-operator">&lt;&lt;</span> <span class="ruby-constant">TMail</span><span class="ruby-operator">::</span><span class="ruby-constant">Mail</span>.<span class="ruby-identifier">parse</span>(<span class="ruby-string">&quot;Content-Type: text/html\r\n\r\n&quot;</span>  <span class="ruby-operator">+</span> <span class="ruby-identifier">props</span>.<span class="ruby-identifier">body_html</span>) <span class="ruby-keyword">if</span> <span class="ruby-identifier">props</span>.<span class="ruby-identifier">body_html</span>&#x000A;                <span class="ruby-comment"># temporarily disabled the rtf. its just showing up as an attachment anyway.</span>&#x000A;                <span class="ruby-comment">#mime.parts &lt;&lt; Mime.new(&quot;Content-Type: text/rtf\r\n\r\n&quot;   + props.body_rtf)  if props.body_rtf</span>&#x000A;                <span class="ruby-comment"># its thus currently possible to get no body at all if the only body is rtf. that is not</span>&#x000A;                <span class="ruby-comment"># really acceptable FIXME</span>&#x000A;                <span class="ruby-identifier">part</span>[<span class="ruby-string">&#39;Content-Type&#39;</span>] = <span class="ruby-string">&#39;multipart/alternative&#39;</span>&#x000A;                <span class="ruby-identifier">part</span>&#x000A;        <span class="ruby-keyword">else</span>&#x000A;                <span class="ruby-comment"># check no header case. content type? etc?. not sure if my Mime class will accept</span>&#x000A;                <span class="ruby-constant">Log</span>.<span class="ruby-identifier">debug</span> <span class="ruby-string">&quot;taking that other path&quot;</span>&#x000A;                <span class="ruby-comment"># body can be nil, hence the to_s</span>&#x000A;                <span class="ruby-constant">TMail</span><span class="ruby-operator">::</span><span class="ruby-constant">Mail</span>.<span class="ruby-identifier">parse</span> <span class="ruby-string">&quot;Content-Type: text/plain\r\n\r\n&quot;</span> <span class="ruby-operator">+</span> <span class="ruby-identifier">props</span>.<span class="ruby-identifier">body</span>.<span class="ruby-identifier">to_s</span>&#x000A;        <span class="ruby-keyword">end</span>&#x000A;<span class="ruby-keyword">end</span></pre>
</div>
</div>
<div class='public-instance method' id='method-method-i-convert'>
<a name='method-i-convert'></a>
<div class='synopsis'>
<span class='name'>convert</span><span class='arguments'>()</span>

</div>
<div class='description'>

</div>
<div class='source'>
<a class='source-toggle' href='#' onclick='toggleCode(&#39;method-i-convert-source&#39;); return false'>
[show source]
</a>
<pre id='method-i-convert-source'><span class="ruby-comment"># File lib/mapi/convert.rb, line 34</span>&#x000A;<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">convert</span>&#x000A;        <span class="ruby-identifier">type</span> = <span class="ruby-identifier">mime_type</span>&#x000A;        <span class="ruby-keyword">unless</span> <span class="ruby-identifier">pair</span> = <span class="ruby-constant">CONVERSION_MAP</span>[<span class="ruby-identifier">type</span>]&#x000A;                <span class="ruby-identifier">raise</span> <span class="ruby-string">&#39;unable to convert message with mime type - %p&#39;</span> <span class="ruby-operator">%</span> <span class="ruby-identifier">type</span>&#x000A;        <span class="ruby-keyword">end</span>&#x000A;        <span class="ruby-identifier">send</span> <span class="ruby-identifier">pair</span>.<span class="ruby-identifier">first</span>&#x000A;<span class="ruby-keyword">end</span></pre>
</div>
</div>
<div class='public-instance method' id='method-method-i-headers'>
<a name='method-i-headers'></a>
<div class='synopsis'>
<span class='name'>headers</span><span class='arguments'>()</span>

</div>
<div class='description'>

</div>
<div class='source'>
<a class='source-toggle' href='#' onclick='toggleCode(&#39;method-i-headers-source&#39;); return false'>
[show source]
</a>
<pre id='method-i-headers-source'><span class="ruby-comment"># File lib/mapi/convert/note-mime.rb, line 23</span>&#x000A;<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">headers</span>&#x000A;        <span class="ruby-identifier">mime</span>.<span class="ruby-identifier">headers</span>&#x000A;<span class="ruby-keyword">end</span></pre>
</div>
</div>
<div class='public-instance method' id='method-method-i-inspect'>
<a name='method-i-inspect'></a>
<div class='synopsis'>
<span class='name'>inspect</span><span class='arguments'>()</span>

</div>
<div class='description'>

</div>
<div class='source'>
<a class='source-toggle' href='#' onclick='toggleCode(&#39;method-i-inspect-source&#39;); return false'>
[show source]
</a>
<pre id='method-i-inspect-source'><span class="ruby-comment"># File lib/mapi/base.rb, line 95</span>&#x000A;<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">inspect</span>&#x000A;        <span class="ruby-identifier">str</span> = <span class="ruby-node">%w[message_class from to subject]</span>.<span class="ruby-identifier">map</span> <span class="ruby-keyword">do</span> <span class="ruby-operator">|</span><span class="ruby-identifier">key</span><span class="ruby-operator">|</span>&#x000A;                <span class="ruby-node">&quot; #{key}=#{props.send(key).inspect}&quot;</span>&#x000A;        <span class="ruby-keyword">end</span>.<span class="ruby-identifier">compact</span>.<span class="ruby-identifier">join</span>&#x000A;        <span class="ruby-identifier">str</span> <span class="ruby-operator">&lt;&lt;</span> <span class="ruby-node">&quot; recipients=#{recipients.inspect}&quot;</span>&#x000A;        <span class="ruby-identifier">str</span> <span class="ruby-operator">&lt;&lt;</span> <span class="ruby-node">&quot; attachments=#{attachments.inspect}&quot;</span>&#x000A;        <span class="ruby-node">&quot;#&lt;#{self.class.to_s[/\w+$/]}#{str}&gt;&quot;</span>&#x000A;<span class="ruby-keyword">end</span></pre>
</div>
</div>
<div class='public-instance method' id='method-method-i-mime'>
<a name='method-i-mime'></a>
<div class='synopsis'>
<span class='name'>mime</span><span class='arguments'>()</span>

</div>
<div class='description'>

</div>
<div class='source'>
<a class='source-toggle' href='#' onclick='toggleCode(&#39;method-i-mime-source&#39;); return false'>
[show source]
</a>
<pre id='method-i-mime-source'><span class="ruby-comment"># File lib/mapi/convert/note-mime.rb, line 9</span>&#x000A;<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">mime</span>&#x000A;        <span class="ruby-keyword">return</span> <span class="ruby-ivar">@mime</span> <span class="ruby-keyword">if</span> <span class="ruby-ivar">@mime</span>&#x000A;        <span class="ruby-comment"># if these headers exist at all, they can be helpful. we may however get a</span>&#x000A;        <span class="ruby-comment"># application/ms-tnef mime root, which means there will be little other than</span>&#x000A;        <span class="ruby-comment"># headers. we may get nothing.</span>&#x000A;        <span class="ruby-comment"># and other times, when received from external, we get the full cigar, boundaries</span>&#x000A;        <span class="ruby-comment"># etc and all.</span>&#x000A;        <span class="ruby-comment"># sometimes its multipart, with no boundaries. that throws an error. so we&#39;ll be more</span>&#x000A;        <span class="ruby-comment"># forgiving here</span>&#x000A;        <span class="ruby-ivar">@mime</span> = <span class="ruby-constant">Mime</span>.<span class="ruby-identifier">new</span> <span class="ruby-identifier">props</span>.<span class="ruby-identifier">transport_message_headers</span>.<span class="ruby-identifier">to_s</span>, <span class="ruby-keyword">true</span>&#x000A;        <span class="ruby-identifier">populate_headers</span>&#x000A;        <span class="ruby-ivar">@mime</span>&#x000A;<span class="ruby-keyword">end</span></pre>
</div>
</div>
<div class='public-instance method' id='method-method-i-mime_type'>
<a name='method-i-mime_type'></a>
<div class='synopsis'>
<span class='name'>mime_type</span><span class='arguments'>()</span>

</div>
<div class='description'>

<p>get the mime type of the message.</p>

</div>
<div class='source'>
<a class='source-toggle' href='#' onclick='toggleCode(&#39;method-i-mime_type-source&#39;); return false'>
[show source]
</a>
<pre id='method-i-mime_type-source'><span class="ruby-comment"># File lib/mapi/convert.rb, line 17</span>&#x000A;<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">mime_type</span>&#x000A;        <span class="ruby-keyword">case</span> <span class="ruby-identifier">props</span>.<span class="ruby-identifier">message_class</span> <span class="ruby-comment">#.downcase &lt;- have a feeling i saw other cased versions</span>&#x000A;        <span class="ruby-keyword">when</span> <span class="ruby-string">&#39;IPM.Contact&#39;</span>&#x000A;                <span class="ruby-comment"># apparently &quot;text/directory; profile=vcard&quot; is what you&#39;re supposed to use</span>&#x000A;                <span class="ruby-string">&#39;text/x-vcard&#39;</span>&#x000A;        <span class="ruby-keyword">when</span> <span class="ruby-string">&#39;IPM.Note&#39;</span>&#x000A;                <span class="ruby-string">&#39;message/rfc822&#39;</span>&#x000A;        <span class="ruby-keyword">when</span> <span class="ruby-string">&#39;IPM.Post&#39;</span>&#x000A;                <span class="ruby-string">&#39;text/plain&#39;</span>&#x000A;        <span class="ruby-keyword">when</span> <span class="ruby-string">&#39;IPM.StickyNote&#39;</span>&#x000A;                <span class="ruby-string">&#39;text/plain&#39;</span> <span class="ruby-comment"># hmmm....</span>&#x000A;        <span class="ruby-keyword">else</span>&#x000A;                <span class="ruby-constant">Mapi</span><span class="ruby-operator">::</span><span class="ruby-constant">Log</span>.<span class="ruby-identifier">warn</span> <span class="ruby-string">&#39;unknown message_class - %p&#39;</span> <span class="ruby-operator">%</span> <span class="ruby-identifier">props</span>.<span class="ruby-identifier">message_class</span>&#x000A;                <span class="ruby-keyword">nil</span>&#x000A;        <span class="ruby-keyword">end</span>&#x000A;<span class="ruby-keyword">end</span></pre>
</div>
</div>
<div class='public-instance method' id='method-method-i-populate_headers'>
<a name='method-i-populate_headers'></a>
<div class='synopsis'>
<span class='name'>populate_headers</span><span class='arguments'>()</span>

</div>
<div class='description'>

<p>copy data from msg properties storage to standard mime. headers i&#39;ve now seen it where the existing headers had heaps on stuff, and the msg#props had practically nothing. think it was because it was a tnef - msg conversion done by exchange.</p>

</div>
<div class='source'>
<a class='source-toggle' href='#' onclick='toggleCode(&#39;method-i-populate_headers-source&#39;); return false'>
[show source]
</a>
<pre id='method-i-populate_headers-source'><span class="ruby-comment"># File lib/mapi/convert/note-mime.rb, line 30</span>&#x000A;<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">populate_headers</span>&#x000A;        <span class="ruby-comment"># construct a From value</span>&#x000A;        <span class="ruby-comment"># should this kind of thing only be done when headers don&#39;t exist already? maybe not. if its</span>&#x000A;        <span class="ruby-comment"># sent, then modified and saved, the headers could be wrong?</span>&#x000A;        <span class="ruby-comment"># hmmm. i just had an example where a mail is sent, from an internal user, but it has transport</span>&#x000A;        <span class="ruby-comment"># headers, i think because one recipient was external. the only place the senders email address</span>&#x000A;        <span class="ruby-comment"># exists is in the transport headers. so its maybe not good to overwrite from.</span>&#x000A;        <span class="ruby-comment"># recipients however usually have smtp address available.</span>&#x000A;        <span class="ruby-comment"># maybe we&#39;ll do it for all addresses that are smtp? (is that equivalent to</span>&#x000A;        <span class="ruby-comment"># sender_email_address !~ /^\//</span>&#x000A;        <span class="ruby-identifier">name</span>, <span class="ruby-identifier">email</span> = <span class="ruby-identifier">props</span>.<span class="ruby-identifier">sender_name</span>, <span class="ruby-identifier">props</span>.<span class="ruby-identifier">sender_email_address</span>&#x000A;        <span class="ruby-keyword">if</span> <span class="ruby-identifier">props</span>.<span class="ruby-identifier">sender_addrtype</span> <span class="ruby-operator">==</span> <span class="ruby-string">&#39;SMTP&#39;</span>&#x000A;                <span class="ruby-identifier">headers</span>[<span class="ruby-string">&#39;From&#39;</span>] = <span class="ruby-keyword">if</span> <span class="ruby-identifier">name</span> <span class="ruby-keyword">and</span> <span class="ruby-identifier">email</span> <span class="ruby-keyword">and</span> <span class="ruby-identifier">name</span> <span class="ruby-operator">!=</span> <span class="ruby-identifier">email</span>&#x000A;                        [<span class="ruby-node">%{&quot;#{name}&quot; &lt;#{email}&gt;}</span>]&#x000A;                <span class="ruby-keyword">else</span>&#x000A;                        [<span class="ruby-identifier">email</span> <span class="ruby-operator">||</span> <span class="ruby-identifier">name</span>]&#x000A;                <span class="ruby-keyword">end</span>&#x000A;        <span class="ruby-keyword">elsif</span> <span class="ruby-operator">!</span><span class="ruby-identifier">headers</span>.<span class="ruby-identifier">has_key?</span>(<span class="ruby-string">&#39;From&#39;</span>)&#x000A;                <span class="ruby-comment"># some messages were never sent, so that sender stuff isn&#39;t filled out. need to find another</span>&#x000A;                <span class="ruby-comment"># way to get something</span>&#x000A;                <span class="ruby-comment"># what about marking whether we thing the email was sent or not? or draft?</span>&#x000A;                <span class="ruby-comment"># for partition into an eventual Inbox, Sent, Draft mbox set?</span>&#x000A;                <span class="ruby-comment"># i&#39;ve now seen cases where this stuff is missing, but exists in transport message headers,</span>&#x000A;                <span class="ruby-comment"># so maybe i should inhibit this in that case.</span>&#x000A;                <span class="ruby-keyword">if</span> <span class="ruby-identifier">email</span>&#x000A;                        <span class="ruby-comment"># disabling this warning for now</span>&#x000A;                        <span class="ruby-comment">#Log.warn &quot;* no smtp sender email address available (only X.400). creating fake one&quot;</span>&#x000A;                        <span class="ruby-comment"># this is crap. though i&#39;ve specially picked the logic so that it generates the correct</span>&#x000A;                        <span class="ruby-comment"># email addresses in my case (for my organisation).</span>&#x000A;                        <span class="ruby-comment"># this user stuff will give valid email i think, based on alias.</span>&#x000A;                        <span class="ruby-identifier">user</span> = <span class="ruby-identifier">name</span> <span class="ruby-operator">?</span> <span class="ruby-identifier">name</span>.<span class="ruby-identifier">sub</span>(<span class="ruby-regexp">/(.*), (.*)/</span>, <span class="ruby-string">&quot;\\2.\\1&quot;</span>) <span class="ruby-operator">:</span> <span class="ruby-identifier">email</span>[<span class="ruby-regexp">/\w+$/</span>].<span class="ruby-identifier">downcase</span>&#x000A;                        <span class="ruby-identifier">domain</span> = (<span class="ruby-identifier">email</span>[<span class="ruby-regexp">%r{^/O=([^/]+)}i</span>, <span class="ruby-value">1</span>].<span class="ruby-identifier">downcase</span> <span class="ruby-operator">+</span> <span class="ruby-string">&#39;.com&#39;</span> <span class="ruby-keyword">rescue</span> <span class="ruby-identifier">email</span>)&#x000A;                        <span class="ruby-identifier">headers</span>[<span class="ruby-string">&#39;From&#39;</span>] = [<span class="ruby-identifier">name</span> <span class="ruby-operator">?</span> <span class="ruby-node">%{&quot;#{name}&quot; &lt;#{user}@#{domain}&gt;}</span> <span class="ruby-operator">:</span> <span class="ruby-node">&quot;&lt;#{user}@#{domain}&gt;&quot;</span> ]&#x000A;                <span class="ruby-keyword">elsif</span> <span class="ruby-identifier">name</span>&#x000A;                        <span class="ruby-comment"># we only have a name? thats screwed up.</span>&#x000A;                        <span class="ruby-comment"># disabling this warning for now</span>&#x000A;                        <span class="ruby-comment">#Log.warn &quot;* no smtp sender email address available (only name). creating fake one&quot;</span>&#x000A;                        <span class="ruby-identifier">headers</span>[<span class="ruby-string">&#39;From&#39;</span>] = [<span class="ruby-node">%{&quot;#{name}&quot;}</span>]&#x000A;                <span class="ruby-keyword">else</span>&#x000A;                        <span class="ruby-comment"># disabling this warning for now</span>&#x000A;                        <span class="ruby-comment">#Log.warn &quot;* no sender email address available at all. FIXME&quot;</span>&#x000A;                <span class="ruby-keyword">end</span>&#x000A;        <span class="ruby-comment"># else we leave the transport message header version</span>&#x000A;        <span class="ruby-keyword">end</span>&#x000A;&#x000A;        <span class="ruby-comment"># for all of this stuff, i&#39;m assigning in utf8 strings.</span>&#x000A;        <span class="ruby-comment"># thats ok i suppose, maybe i can say its the job of the mime class to handle that.</span>&#x000A;        <span class="ruby-comment"># but a lot of the headers are overloaded in different ways. plain string, many strings</span>&#x000A;        <span class="ruby-comment"># other stuff. what happens to a person who has a &quot; in their name etc etc. encoded words</span>&#x000A;        <span class="ruby-comment"># i suppose. but that then happens before assignment. and can&#39;t be automatically undone</span>&#x000A;        <span class="ruby-comment"># until the header is decomposed into recipients.</span>&#x000A;        <span class="ruby-identifier">recips_by_type</span> = <span class="ruby-identifier">recipients</span>.<span class="ruby-identifier">group_by</span> { <span class="ruby-operator">|</span><span class="ruby-identifier">r</span><span class="ruby-operator">|</span> <span class="ruby-identifier">r</span>.<span class="ruby-identifier">type</span> }&#x000A;        <span class="ruby-comment"># i want to the the types in a specific order.</span>&#x000A;        [<span class="ruby-value">:to</span>, <span class="ruby-value">:cc</span>, <span class="ruby-value">:bcc</span>].<span class="ruby-identifier">each</span> <span class="ruby-keyword">do</span> <span class="ruby-operator">|</span><span class="ruby-identifier">type</span><span class="ruby-operator">|</span>&#x000A;                <span class="ruby-comment"># for maximal (probably pointless) fidelity, we try to sort recipients by the</span>&#x000A;                <span class="ruby-comment"># numerical part of the ole name</span>&#x000A;                <span class="ruby-identifier">recips</span> = <span class="ruby-identifier">recips_by_type</span>[<span class="ruby-identifier">type</span>] <span class="ruby-operator">||</span> []&#x000A;                <span class="ruby-identifier">recips</span> = (<span class="ruby-identifier">recips</span>.<span class="ruby-identifier">sort_by</span> { <span class="ruby-operator">|</span><span class="ruby-identifier">r</span><span class="ruby-operator">|</span> <span class="ruby-identifier">r</span>.<span class="ruby-identifier">obj</span>.<span class="ruby-identifier">name</span>[<span class="ruby-regexp">/\d{8}$/</span>].<span class="ruby-identifier">hex</span> } <span class="ruby-keyword">rescue</span> <span class="ruby-identifier">recips</span>)&#x000A;                <span class="ruby-comment"># switched to using , for separation, not ;. see issue #4</span>&#x000A;                <span class="ruby-comment"># recips.empty? is strange. i wouldn&#39;t have thought it possible, but it was right?</span>&#x000A;                <span class="ruby-identifier">headers</span>[<span class="ruby-identifier">type</span>.<span class="ruby-identifier">to_s</span>.<span class="ruby-identifier">sub</span>(<span class="ruby-regexp">/^(.)/</span>) { <span class="ruby-node">$1</span>.<span class="ruby-identifier">upcase</span> }] = [<span class="ruby-identifier">recips</span>.<span class="ruby-identifier">join</span>(<span class="ruby-string">&#39;, &#39;</span>)] <span class="ruby-keyword">unless</span> <span class="ruby-identifier">recips</span>.<span class="ruby-identifier">empty?</span>&#x000A;        <span class="ruby-keyword">end</span>&#x000A;        <span class="ruby-identifier">headers</span>[<span class="ruby-string">&#39;Subject&#39;</span>] = [<span class="ruby-identifier">props</span>.<span class="ruby-identifier">subject</span>] <span class="ruby-keyword">if</span> <span class="ruby-identifier">props</span>.<span class="ruby-identifier">subject</span>&#x000A;&#x000A;        <span class="ruby-comment"># fill in a date value. by default, we won&#39;t mess with existing value hear</span>&#x000A;        <span class="ruby-keyword">if</span> <span class="ruby-operator">!</span><span class="ruby-identifier">headers</span>.<span class="ruby-identifier">has_key?</span>(<span class="ruby-string">&#39;Date&#39;</span>)&#x000A;                <span class="ruby-comment"># we want to get a received date, as i understand it.</span>&#x000A;                <span class="ruby-comment"># use this preference order, or pull the most recent?</span>&#x000A;                <span class="ruby-identifier">keys</span> = <span class="ruby-node">%w[message_delivery_time client_submit_time last_modification_time creation_time]</span>&#x000A;                <span class="ruby-identifier">time</span> = <span class="ruby-identifier">keys</span>.<span class="ruby-identifier">each</span> { <span class="ruby-operator">|</span><span class="ruby-identifier">key</span><span class="ruby-operator">|</span> <span class="ruby-keyword">break</span> <span class="ruby-identifier">time</span> <span class="ruby-keyword">if</span> <span class="ruby-identifier">time</span> = <span class="ruby-identifier">props</span>.<span class="ruby-identifier">send</span>(<span class="ruby-identifier">key</span>) }&#x000A;                <span class="ruby-identifier">time</span> = <span class="ruby-keyword">nil</span> <span class="ruby-keyword">unless</span> <span class="ruby-constant">Date</span> <span class="ruby-operator">===</span> <span class="ruby-identifier">time</span>&#x000A;&#x000A;                <span class="ruby-comment"># now convert and store</span>&#x000A;                <span class="ruby-comment"># this is a little funky. not sure about time zone stuff either?</span>&#x000A;                <span class="ruby-comment"># actually seems ok. maybe its always UTC and interpreted anyway. or can be timezoneless.</span>&#x000A;                <span class="ruby-comment"># i have no timezone info anyway.</span>&#x000A;                <span class="ruby-comment"># in gmail, i see stuff like 15 Jan 2007 00:48:19 -0000, and it displays as 11:48.</span>&#x000A;                <span class="ruby-comment"># can also add .localtime here if desired. but that feels wrong.</span>&#x000A;                <span class="ruby-identifier">headers</span>[<span class="ruby-string">&#39;Date&#39;</span>] = [<span class="ruby-constant">Time</span>.<span class="ruby-identifier">iso8601</span>(<span class="ruby-identifier">time</span>.<span class="ruby-identifier">to_s</span>).<span class="ruby-identifier">rfc2822</span>] <span class="ruby-keyword">if</span> <span class="ruby-identifier">time</span>&#x000A;        <span class="ruby-keyword">end</span>&#x000A;&#x000A;        <span class="ruby-comment"># some very simplistic mapping between internet message headers and the</span>&#x000A;        <span class="ruby-comment"># mapi properties</span>&#x000A;        <span class="ruby-comment"># any of these could be causing duplicates due to case issues. the hack in #to_mime</span>&#x000A;        <span class="ruby-comment"># just stops re-duplication at that point. need to move some smarts into the mime</span>&#x000A;        <span class="ruby-comment"># code to handle it.</span>&#x000A;        <span class="ruby-identifier">mapi_header_map</span> = [&#x000A;                [<span class="ruby-value">:internet_message_id</span>, <span class="ruby-string">&#39;Message-ID&#39;</span>],&#x000A;                [<span class="ruby-value">:in_reply_to_id</span>, <span class="ruby-string">&#39;In-Reply-To&#39;</span>],&#x000A;                <span class="ruby-comment"># don&#39;t set these values if they&#39;re equal to the defaults anyway</span>&#x000A;                [<span class="ruby-value">:importance</span>, <span class="ruby-string">&#39;Importance&#39;</span>, <span class="ruby-identifier">proc</span> { <span class="ruby-operator">|</span><span class="ruby-identifier">val</span><span class="ruby-operator">|</span> <span class="ruby-identifier">val</span>.<span class="ruby-identifier">to_s</span> <span class="ruby-operator">==</span> <span class="ruby-string">&#39;1&#39;</span> <span class="ruby-operator">?</span> <span class="ruby-keyword">nil</span> <span class="ruby-operator">:</span> <span class="ruby-identifier">val</span> }],&#x000A;                [<span class="ruby-value">:priority</span>, <span class="ruby-string">&#39;Priority&#39;</span>, <span class="ruby-identifier">proc</span> { <span class="ruby-operator">|</span><span class="ruby-identifier">val</span><span class="ruby-operator">|</span> <span class="ruby-identifier">val</span>.<span class="ruby-identifier">to_s</span> <span class="ruby-operator">==</span> <span class="ruby-string">&#39;1&#39;</span> <span class="ruby-operator">?</span> <span class="ruby-keyword">nil</span> <span class="ruby-operator">:</span> <span class="ruby-identifier">val</span> }],&#x000A;                [<span class="ruby-value">:sensitivity</span>, <span class="ruby-string">&#39;Sensitivity&#39;</span>, <span class="ruby-identifier">proc</span> { <span class="ruby-operator">|</span><span class="ruby-identifier">val</span><span class="ruby-operator">|</span> <span class="ruby-identifier">val</span>.<span class="ruby-identifier">to_s</span> <span class="ruby-operator">==</span> <span class="ruby-string">&#39;0&#39;</span> <span class="ruby-operator">?</span> <span class="ruby-keyword">nil</span> <span class="ruby-operator">:</span> <span class="ruby-identifier">val</span> }],&#x000A;                <span class="ruby-comment"># yeah?</span>&#x000A;                [<span class="ruby-value">:conversation_topic</span>, <span class="ruby-string">&#39;Thread-Topic&#39;</span>],&#x000A;                <span class="ruby-comment"># not sure of the distinction here</span>&#x000A;                <span class="ruby-comment"># :originator_delivery_report_requested ??</span>&#x000A;                [<span class="ruby-value">:read_receipt_requested</span>, <span class="ruby-string">&#39;Disposition-Notification-To&#39;</span>, <span class="ruby-identifier">proc</span> { <span class="ruby-operator">|</span><span class="ruby-identifier">val</span><span class="ruby-operator">|</span> <span class="ruby-identifier">from</span> }]&#x000A;        ]&#x000A;        <span class="ruby-identifier">mapi_header_map</span>.<span class="ruby-identifier">each</span> <span class="ruby-keyword">do</span> <span class="ruby-operator">|</span><span class="ruby-identifier">mapi</span>, <span class="ruby-identifier">mime</span>, <span class="ruby-operator">*</span><span class="ruby-identifier">f</span><span class="ruby-operator">|</span>&#x000A;                <span class="ruby-keyword">next</span> <span class="ruby-keyword">unless</span> <span class="ruby-identifier">q</span> = <span class="ruby-identifier">val</span> = <span class="ruby-identifier">props</span>.<span class="ruby-identifier">send</span>(<span class="ruby-identifier">mapi</span>) <span class="ruby-keyword">or</span> <span class="ruby-identifier">headers</span>.<span class="ruby-identifier">has_key?</span>(<span class="ruby-identifier">mime</span>)&#x000A;                <span class="ruby-keyword">next</span> <span class="ruby-keyword">if</span> <span class="ruby-identifier">f</span>[<span class="ruby-value">0</span>] <span class="ruby-keyword">and</span> <span class="ruby-operator">!</span>(<span class="ruby-identifier">val</span> = <span class="ruby-identifier">f</span>[<span class="ruby-value">0</span>].<span class="ruby-identifier">call</span>(<span class="ruby-identifier">val</span>))&#x000A;                <span class="ruby-identifier">headers</span>[<span class="ruby-identifier">mime</span>] = [<span class="ruby-identifier">val</span>.<span class="ruby-identifier">to_s</span>]&#x000A;        <span class="ruby-keyword">end</span>&#x000A;<span class="ruby-keyword">end</span></pre>
</div>
</div>
<div class='public-instance method' id='method-method-i-recipients'>
<a name='method-i-recipients'></a>
<div class='synopsis'>
<span class='name'>recipients</span><span class='arguments'>()</span>

</div>
<div class='description'>

</div>
<div class='source'>
<a class='source-toggle' href='#' onclick='toggleCode(&#39;method-i-recipients-source&#39;); return false'>
[show source]
</a>
<pre id='method-i-recipients-source'><span class="ruby-comment"># File lib/mapi/base.rb, line 91</span>&#x000A;<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">recipients</span>&#x000A;        <span class="ruby-identifier">raise</span> <span class="ruby-constant">NotImplementedError</span>&#x000A;<span class="ruby-keyword">end</span></pre>
</div>
</div>
<div class='public-instance method' id='method-method-i-to_mime'>
<a name='method-i-to_mime'></a>
<div class='synopsis'>
<span class='name'>to_mime</span><span class='arguments'>()</span>

</div>
<div class='description'>

</div>
<div class='source'>
<a class='source-toggle' href='#' onclick='toggleCode(&#39;method-i-to_mime-source&#39;); return false'>
[show source]
</a>
<pre id='method-i-to_mime-source'><span class="ruby-comment"># File lib/mapi/convert/note-mime.rb, line 173</span>&#x000A;<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">to_mime</span>&#x000A;        <span class="ruby-comment"># intended to be used for IPM.note, which is the email type. can use it for others if desired,</span>&#x000A;        <span class="ruby-comment"># YMMV</span>&#x000A;        <span class="ruby-constant">Log</span>.<span class="ruby-identifier">warn</span> <span class="ruby-node">&quot;to_mime used on a #{props.message_class}&quot;</span> <span class="ruby-keyword">unless</span> <span class="ruby-identifier">props</span>.<span class="ruby-identifier">message_class</span> <span class="ruby-operator">==</span> <span class="ruby-string">&#39;IPM.Note&#39;</span>&#x000A;        <span class="ruby-comment"># we always have a body</span>&#x000A;        <span class="ruby-identifier">mime</span> = <span class="ruby-identifier">body</span> = <span class="ruby-identifier">body_to_mime</span>&#x000A;&#x000A;        <span class="ruby-comment"># If we have attachments, we take the current mime root (body), and make it the first child</span>&#x000A;        <span class="ruby-comment"># of a new tree that will contain body and attachments.</span>&#x000A;        <span class="ruby-keyword">unless</span> <span class="ruby-identifier">attachments</span>.<span class="ruby-identifier">empty?</span>&#x000A;                <span class="ruby-identifier">mime</span> = <span class="ruby-constant">Mime</span>.<span class="ruby-identifier">new</span> <span class="ruby-string">&quot;Content-Type: multipart/mixed\r\n\r\n&quot;</span>&#x000A;                <span class="ruby-identifier">mime</span>.<span class="ruby-identifier">parts</span> <span class="ruby-operator">&lt;&lt;</span> <span class="ruby-identifier">body</span>&#x000A;                <span class="ruby-comment"># i don&#39;t know any better way to do this. need multipart/related for inline images</span>&#x000A;                <span class="ruby-comment"># referenced by cid: urls to work, but don&#39;t want to use it otherwise...</span>&#x000A;                <span class="ruby-identifier">related</span> = <span class="ruby-keyword">false</span>&#x000A;                <span class="ruby-identifier">attachments</span>.<span class="ruby-identifier">each</span> <span class="ruby-keyword">do</span> <span class="ruby-operator">|</span><span class="ruby-identifier">attach</span><span class="ruby-operator">|</span>&#x000A;                        <span class="ruby-identifier">part</span> = <span class="ruby-identifier">attach</span>.<span class="ruby-identifier">to_mime</span>&#x000A;                        <span class="ruby-identifier">related</span> = <span class="ruby-keyword">true</span> <span class="ruby-keyword">if</span> <span class="ruby-identifier">part</span>.<span class="ruby-identifier">headers</span>.<span class="ruby-identifier">has_key?</span>(<span class="ruby-string">&#39;Content-ID&#39;</span>) <span class="ruby-keyword">or</span> <span class="ruby-identifier">part</span>.<span class="ruby-identifier">headers</span>.<span class="ruby-identifier">has_key?</span>(<span class="ruby-string">&#39;Content-Location&#39;</span>)&#x000A;                        <span class="ruby-identifier">mime</span>.<span class="ruby-identifier">parts</span> <span class="ruby-operator">&lt;&lt;</span> <span class="ruby-identifier">part</span>&#x000A;                <span class="ruby-keyword">end</span>&#x000A;                <span class="ruby-identifier">mime</span>.<span class="ruby-identifier">headers</span>[<span class="ruby-string">&#39;Content-Type&#39;</span>] = [<span class="ruby-string">&#39;multipart/related&#39;</span>] <span class="ruby-keyword">if</span> <span class="ruby-identifier">related</span>&#x000A;        <span class="ruby-keyword">end</span>&#x000A;&#x000A;        <span class="ruby-comment"># at this point, mime is either</span>&#x000A;        <span class="ruby-comment"># - a single text/plain, consisting of the body (&#39;taking that other path&#39; above. rare)</span>&#x000A;        <span class="ruby-comment"># - a multipart/alternative, consiting of a few bodies (plain and html body. common)</span>&#x000A;        <span class="ruby-comment"># - a multipart/mixed, consisting of 1 of the above 2 types of bodies, and attachments.</span>&#x000A;        <span class="ruby-comment"># we add this standard preamble if its multipart</span>&#x000A;        <span class="ruby-comment"># FIXME preamble.replace, and body.replace both suck.</span>&#x000A;        <span class="ruby-comment"># preamble= is doable. body= wasn&#39;t being done because body will get rewritten from parts</span>&#x000A;        <span class="ruby-comment"># if multipart, and is only there readonly. can do that, or do a reparse...</span>&#x000A;        <span class="ruby-comment"># The way i do this means that only the first preamble will say it, not preambles of nested</span>&#x000A;        <span class="ruby-comment"># multipart chunks.</span>&#x000A;        <span class="ruby-identifier">mime</span>.<span class="ruby-identifier">preamble</span>.<span class="ruby-identifier">replace</span> <span class="ruby-string">&quot;This is a multi-part message in MIME format.\r\n&quot;</span> <span class="ruby-keyword">if</span> <span class="ruby-identifier">mime</span>.<span class="ruby-identifier">multipart?</span>&#x000A;&#x000A;        <span class="ruby-comment"># now that we have a root, we can mix in all our headers</span>&#x000A;        <span class="ruby-identifier">headers</span>.<span class="ruby-identifier">each</span> <span class="ruby-keyword">do</span> <span class="ruby-operator">|</span><span class="ruby-identifier">key</span>, <span class="ruby-identifier">vals</span><span class="ruby-operator">|</span>&#x000A;                <span class="ruby-comment"># don&#39;t overwrite the content-type, encoding style stuff</span>&#x000A;                <span class="ruby-keyword">next</span> <span class="ruby-keyword">if</span> <span class="ruby-identifier">mime</span>.<span class="ruby-identifier">headers</span>.<span class="ruby-identifier">has_key?</span> <span class="ruby-identifier">key</span>&#x000A;                <span class="ruby-comment"># some new temporary hacks</span>&#x000A;                <span class="ruby-keyword">next</span> <span class="ruby-keyword">if</span> <span class="ruby-identifier">key</span> <span class="ruby-operator">=~</span> <span class="ruby-regexp">/content-type/i</span> <span class="ruby-keyword">and</span> <span class="ruby-identifier">vals</span>[<span class="ruby-value">0</span>] <span class="ruby-operator">=~</span> <span class="ruby-regexp">/base64/</span>&#x000A;                <span class="ruby-keyword">next</span> <span class="ruby-keyword">if</span> <span class="ruby-identifier">mime</span>.<span class="ruby-identifier">headers</span>.<span class="ruby-identifier">keys</span>.<span class="ruby-identifier">map</span>(<span class="ruby-operator">&amp;</span><span class="ruby-value">:downcase</span>).<span class="ruby-identifier">include?</span> <span class="ruby-identifier">key</span>.<span class="ruby-identifier">downcase</span>&#x000A;                <span class="ruby-identifier">mime</span>.<span class="ruby-identifier">headers</span>[<span class="ruby-identifier">key</span>] <span class="ruby-operator">+=</span> <span class="ruby-identifier">vals</span>&#x000A;        <span class="ruby-keyword">end</span>&#x000A;        <span class="ruby-comment"># just a stupid hack to make the content-type header last</span>&#x000A;        <span class="ruby-identifier">mime</span>.<span class="ruby-identifier">headers</span>[<span class="ruby-string">&#39;Content-Type&#39;</span>] = <span class="ruby-identifier">mime</span>.<span class="ruby-identifier">headers</span>.<span class="ruby-identifier">delete</span> <span class="ruby-string">&#39;Content-Type&#39;</span>&#x000A;&#x000A;        <span class="ruby-identifier">mime</span>&#x000A;<span class="ruby-keyword">end</span></pre>
</div>
</div>
<div class='public-instance method' id='method-method-i-to_post'>
<a name='method-i-to_post'></a>
<div class='synopsis'>
<span class='name'>to_post</span><span class='arguments'>()</span>

</div>
<div class='description'>

</div>
<div class='source'>
<a class='source-toggle' href='#' onclick='toggleCode(&#39;method-i-to_post-source&#39;); return false'>
[show source]
</a>
<pre id='method-i-to_post-source'><span class="ruby-comment"># File lib/mapi/convert.rb, line 56</span>&#x000A;<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">to_post</span>&#x000A;        <span class="ruby-constant">Post</span>.<span class="ruby-identifier">new</span> <span class="ruby-keyword">self</span>&#x000A;<span class="ruby-keyword">end</span></pre>
</div>
</div>
<div class='public-instance method' id='method-method-i-to_tmail'>
<a name='method-i-to_tmail'></a>
<div class='synopsis'>
<span class='name'>to_tmail</span><span class='arguments'>()</span>

</div>
<div class='description'>

</div>
<div class='source'>
<a class='source-toggle' href='#' onclick='toggleCode(&#39;method-i-to_tmail-source&#39;); return false'>
[show source]
</a>
<pre id='method-i-to_tmail-source'><span class="ruby-comment"># File lib/mapi/convert/note-tmail.rb, line 184</span>&#x000A;<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">to_tmail</span>&#x000A;        <span class="ruby-comment"># intended to be used for IPM.note, which is the email type. can use it for others if desired,</span>&#x000A;        <span class="ruby-comment"># YMMV</span>&#x000A;        <span class="ruby-constant">Log</span>.<span class="ruby-identifier">warn</span> <span class="ruby-node">&quot;to_mime used on a #{props.message_class}&quot;</span> <span class="ruby-keyword">unless</span> <span class="ruby-identifier">props</span>.<span class="ruby-identifier">message_class</span> <span class="ruby-operator">==</span> <span class="ruby-string">&#39;IPM.Note&#39;</span>&#x000A;        <span class="ruby-comment"># we always have a body</span>&#x000A;        <span class="ruby-identifier">mail</span> = <span class="ruby-identifier">body</span> = <span class="ruby-identifier">body_to_tmail</span>&#x000A;&#x000A;        <span class="ruby-comment"># If we have attachments, we take the current mime root (body), and make it the first child</span>&#x000A;        <span class="ruby-comment"># of a new tree that will contain body and attachments.</span>&#x000A;        <span class="ruby-keyword">unless</span> <span class="ruby-identifier">attachments</span>.<span class="ruby-identifier">empty?</span>&#x000A;                <span class="ruby-identifier">raise</span> <span class="ruby-constant">NotImplementedError</span>&#x000A;                <span class="ruby-identifier">mime</span> = <span class="ruby-constant">Mime</span>.<span class="ruby-identifier">new</span> <span class="ruby-string">&quot;Content-Type: multipart/mixed\r\n\r\n&quot;</span>&#x000A;                <span class="ruby-identifier">mime</span>.<span class="ruby-identifier">parts</span> <span class="ruby-operator">&lt;&lt;</span> <span class="ruby-identifier">body</span>&#x000A;                <span class="ruby-comment"># i don&#39;t know any better way to do this. need multipart/related for inline images</span>&#x000A;                <span class="ruby-comment"># referenced by cid: urls to work, but don&#39;t want to use it otherwise...</span>&#x000A;                <span class="ruby-identifier">related</span> = <span class="ruby-keyword">false</span>&#x000A;                <span class="ruby-identifier">attachments</span>.<span class="ruby-identifier">each</span> <span class="ruby-keyword">do</span> <span class="ruby-operator">|</span><span class="ruby-identifier">attach</span><span class="ruby-operator">|</span>&#x000A;                        <span class="ruby-identifier">part</span> = <span class="ruby-identifier">attach</span>.<span class="ruby-identifier">to_mime</span>&#x000A;                        <span class="ruby-identifier">related</span> = <span class="ruby-keyword">true</span> <span class="ruby-keyword">if</span> <span class="ruby-identifier">part</span>.<span class="ruby-identifier">headers</span>.<span class="ruby-identifier">has_key?</span>(<span class="ruby-string">&#39;Content-ID&#39;</span>) <span class="ruby-keyword">or</span> <span class="ruby-identifier">part</span>.<span class="ruby-identifier">headers</span>.<span class="ruby-identifier">has_key?</span>(<span class="ruby-string">&#39;Content-Location&#39;</span>)&#x000A;                        <span class="ruby-identifier">mime</span>.<span class="ruby-identifier">parts</span> <span class="ruby-operator">&lt;&lt;</span> <span class="ruby-identifier">part</span>&#x000A;                <span class="ruby-keyword">end</span>&#x000A;                <span class="ruby-identifier">mime</span>.<span class="ruby-identifier">headers</span>[<span class="ruby-string">&#39;Content-Type&#39;</span>] = [<span class="ruby-string">&#39;multipart/related&#39;</span>] <span class="ruby-keyword">if</span> <span class="ruby-identifier">related</span>&#x000A;        <span class="ruby-keyword">end</span>&#x000A;&#x000A;        <span class="ruby-comment"># at this point, mime is either</span>&#x000A;        <span class="ruby-comment"># - a single text/plain, consisting of the body (&#39;taking that other path&#39; above. rare)</span>&#x000A;        <span class="ruby-comment"># - a multipart/alternative, consiting of a few bodies (plain and html body. common)</span>&#x000A;        <span class="ruby-comment"># - a multipart/mixed, consisting of 1 of the above 2 types of bodies, and attachments.</span>&#x000A;        <span class="ruby-comment"># we add this standard preamble if its multipart</span>&#x000A;        <span class="ruby-comment"># FIXME preamble.replace, and body.replace both suck.</span>&#x000A;        <span class="ruby-comment"># preamble= is doable. body= wasn&#39;t being done because body will get rewritten from parts</span>&#x000A;        <span class="ruby-comment"># if multipart, and is only there readonly. can do that, or do a reparse...</span>&#x000A;        <span class="ruby-comment"># The way i do this means that only the first preamble will say it, not preambles of nested</span>&#x000A;        <span class="ruby-comment"># multipart chunks.</span>&#x000A;        <span class="ruby-identifier">mail</span>.<span class="ruby-identifier">quoted_body</span> = <span class="ruby-string">&quot;This is a multi-part message in MIME format.\r\n&quot;</span> <span class="ruby-keyword">if</span> <span class="ruby-identifier">mail</span>.<span class="ruby-identifier">multipart?</span>&#x000A;&#x000A;        <span class="ruby-comment"># now that we have a root, we can mix in all our headers</span>&#x000A;        <span class="ruby-identifier">headers</span>.<span class="ruby-identifier">each</span> <span class="ruby-keyword">do</span> <span class="ruby-operator">|</span><span class="ruby-identifier">key</span>, <span class="ruby-identifier">vals</span><span class="ruby-operator">|</span>&#x000A;                <span class="ruby-comment"># don&#39;t overwrite the content-type, encoding style stuff</span>&#x000A;                <span class="ruby-keyword">next</span> <span class="ruby-keyword">if</span> <span class="ruby-identifier">mail</span>[<span class="ruby-identifier">key</span>]&#x000A;                <span class="ruby-comment"># some new temporary hacks</span>&#x000A;                <span class="ruby-keyword">next</span> <span class="ruby-keyword">if</span> <span class="ruby-identifier">key</span> <span class="ruby-operator">=~</span> <span class="ruby-regexp">/content-type/i</span> <span class="ruby-keyword">and</span> <span class="ruby-identifier">vals</span>[<span class="ruby-value">0</span>] <span class="ruby-operator">=~</span> <span class="ruby-regexp">/base64/</span>&#x000A;                <span class="ruby-comment">#next if mime.headers.keys.map(&amp;:downcase).include? key.downcase</span>&#x000A;                <span class="ruby-identifier">mail</span>[<span class="ruby-identifier">key</span>] = <span class="ruby-identifier">vals</span>.<span class="ruby-identifier">first</span>&#x000A;        <span class="ruby-keyword">end</span>&#x000A;        <span class="ruby-comment"># just a stupid hack to make the content-type header last</span>&#x000A;        <span class="ruby-comment">#mime.headers[&#39;Content-Type&#39;] = mime.headers.delete &#39;Content-Type&#39;</span>&#x000A;&#x000A;        <span class="ruby-identifier">mail</span>&#x000A;<span class="ruby-keyword">end</span></pre>
</div>
</div>
<div class='public-instance method' id='method-method-i-to_vcard'>
<a name='method-i-to_vcard'></a>
<div class='synopsis'>
<span class='name'>to_vcard</span><span class='arguments'>()</span>

</div>
<div class='description'>

</div>
<div class='source'>
<a class='source-toggle' href='#' onclick='toggleCode(&#39;method-i-to_vcard-source&#39;); return false'>
[show source]
</a>
<pre id='method-i-to_vcard-source'><span class="ruby-comment"># File lib/mapi/convert/contact.rb, line 134</span>&#x000A;<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">to_vcard</span>&#x000A;        <span class="ruby-comment">#p props.raw.reject { |key, value| key.guid.inspect !~ /00062004-0000-0000-c000-000000000046/ }.</span>&#x000A;        <span class="ruby-comment">#    map { |key, value| [key.to_sym, value] }.reject { |a, b| b.respond_to? :read }</span>&#x000A;        <span class="ruby-comment">#y props.to_h.reject { |a, b| b.respond_to? :read }</span>&#x000A;        <span class="ruby-constant">VcardConverter</span>.<span class="ruby-identifier">new</span>(<span class="ruby-keyword">self</span>).<span class="ruby-identifier">convert</span>&#x000A;<span class="ruby-keyword">end</span></pre>
</div>
</div>
<div class='public-instance method' id='method-method-i-type'>
<a name='method-i-type'></a>
<div class='synopsis'>
<span class='name'>type</span><span class='arguments'>()</span>

</div>
<div class='description'>

<p>redundant?</p>

</div>
<div class='source'>
<a class='source-toggle' href='#' onclick='toggleCode(&#39;method-i-type-source&#39;); return false'>
[show source]
</a>
<pre id='method-i-type-source'><span class="ruby-comment"># File lib/mapi/convert/note-mime.rb, line 137</span>&#x000A;<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">type</span>&#x000A;        <span class="ruby-identifier">props</span>.<span class="ruby-identifier">message_class</span>[<span class="ruby-regexp">/IPM\.(.*)/</span>, <span class="ruby-value">1</span>].<span class="ruby-identifier">downcase</span> <span class="ruby-keyword">rescue</span> <span class="ruby-keyword">nil</span>&#x000A;<span class="ruby-keyword">end</span></pre>
</div>
</div>
</div>
</div>

</div>
</div>

<div id='footer-push'></div>
</div>
<div id='footer'>
<a href="https://github.com/rdoc/hanna-nouveau"><strong>Hanna Nouveau</strong> RDoc template</a>
</div>
</body>
</html>
